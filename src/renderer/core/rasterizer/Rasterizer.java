package renderer.core.rasterizer;

import renderer.algebra.Matrix;
import renderer.algebra.Vector;
import renderer.algebra.MathUtils;
import renderer.algebra.SizeMismatchException;
import renderer.core.shader.Fragment;
import renderer.core.shader.Shader;

/**
 * The Rasterizer class is responsible for the discretization of geometric
 * primitives
 * (edges and faces) over the screen pixel grid and generates Fragment (pixels
 * with
 * interpolated attributes). Those Fragment are then passed to a Shader object,
 * which will produce the final color of the fragment.
 *
 * @author morin, chambon, cdehais
 */
public class Rasterizer {

    /**
     * The default value for interpolate between 2 points.
     */
    private static final double MIDDLE_DOUBLE_VALUE = .5;

    /**
     * The shader used by the Rasterizer.
     */
    protected Shader shader;

    /**
     * Creates a Rasterizer with the given Shader.
     *
     * @param shader the shader to use
     */
    public Rasterizer(Shader shader) {
        this.shader = shader;
    }

    /**
     * Sets the shader of the Rasterizer.
     *
     * @param shader the shader to use
     */
    public void setShader(Shader shader) {
        this.shader = shader;
    }

    /**
     * Linear interpolation of a Fragment f on the edge defined by Fragment's v1 and
     * v2.
     *
     * @param v1 the first vertex of the edge
     * @param v2 the second vertex of the edge
     * @param f  the fragment to interpolate
     */
    private void interpolate2(Fragment v1, Fragment v2, Fragment f) {
        final int x1 = v1.getX();
        final int y1 = v1.getY();
        final int x2 = v2.getX();
        final int y2 = v2.getY();
        final int x = f.getX();
        final int y = f.getX();

        // corner case in which the two vertices are the same
        double alpha = MIDDLE_DOUBLE_VALUE;
        // if we have more pixel on the horizontal axis
        if (Math.abs(x2 - x1) >= Math.abs(y2 - y1)) {
            if (x2 != x1) {
                // compute alpha only if there are pixels to interpolate
                alpha = (double) (x - x1) / (double) (x2 - x1);
            }
        } else {
            if (y2 != y1) {
                alpha = (double) (y - y1) / (double) (y2 - y1);
            }
        }

        final int numAttributes = f.getNumAttributes();
        for (int i = 0; i < numAttributes; i++) {
            double interpolated = (1.0 - alpha) * v1.getAttribute(i)
                    + alpha * v2.getAttribute(i);
            if (i >= Fragment.COLOR_R && i <= Fragment.COLOR_B) {
                // clamp the color between 0 and 1;
                interpolated = MathUtils.clamp(interpolated, 0., 1.);
            }
            f.setAttribute(i, interpolated);
        }
    }

    /**
     * Swaps x and y coordinates of the fragment. Used by the Bresenham algorithm.
     *
     * @param f the fragment to swap
     */
    private static void swapXAndY(Fragment f) {
        f.setPosition(f.getY(), f.getX());
    }

    /**
     * Rasterizes a vertex on the screen.
     *
     * @param v the fragment drawn
     */
    public void rasterizeVertex(final Fragment v) {

        int x1 = v.getX();
        int y1 = v.getY();

        // For now : just display the vertices
        Fragment f = new Fragment(0, 0);
        final int size = 2;
        for (int i = 0; i < v.getNumAttributes(); i++) {
            f.setAttribute(i, v.getAttribute(i));
        }
        for (int i = -size; i <= size; i++) {
            for (int j = -size; j <= size; j++) {
                f.setPosition(x1 + i, y1 + j);
                shader.shade(f);
            }
        }
    }

    /**
     * Rasterizes the edge between the projected vectors v1 and v2.
     * Generates Fragment's and calls the Shader::shade() method on each of them.
     * The Fragment's are generated by linearly interpolating the attributes of v1
     * and v2.
     *
     * @param v1 the first vertex of the edge
     * @param v2 the second vertex of the edge
     */
    public void rasterizeEdge(Fragment v1, Fragment v2) {
        // This is basically Bresenham's algorithm
        int x1 = v1.getX();
        int y1 = v1.getY();
        int x2 = v2.getX();
        int y2 = v2.getY();

        Fragment fragment = new Fragment(0, 0);

        boolean sym = (Math.abs(y2 - y1) > Math.abs(x2 - x1));
        if (sym) {
            int temp;
            temp = x1;
            x1 = y1;
            y1 = temp;
            temp = x2;
            x2 = y2;
            y2 = temp;
            // swapXAndY (v1);
            // swapXAndY (v2);
        }
        if (x1 > x2) {
            Fragment ftemp;
            int temp;
            temp = x1;
            x1 = x2;
            x2 = temp;
            temp = y1;
            y1 = y2;
            y2 = temp;
            ftemp = v1;
            v1 = v2;
            v2 = ftemp;
        }

        final int ystep = (y1 < y2) ? 1 : -1;

        int err = (x1 - x2) / 2;
        final int dx = (x2 - x1);
        final int dy = Math.abs(y2 - y1);

        int x = x1;
        int y = y1;

        while (x <= x2) {

            fragment.setPosition(x, y);

            if (!shader.isClipped(fragment)) {

                interpolate2(v1, v2, fragment);
                if (sym) {
                    swapXAndY(fragment);
                }
                shader.shade(fragment);
            }

            x += 1;
            err = err + dy;
            if (err > 0) {
                y += ystep;
                err -= dx;
            }
        }
    }

    /**
     * Computes the signed area of the triangle defined by the three vertices v1,
     * v2 and v3.
     *
     * @param v1 the first vertex of the triangle
     * @param v2 the second vertex of the triangle
     * @param v3 the third vertex of the triangle
     * @return the signed area of the triangle
     */
    static double triangleArea(Fragment v1, Fragment v2, Fragment v3) {
        return (double) v2.getX() * v3.getY() - v2.getY() * v3.getX()
                + v3.getX() * v1.getY() - v1.getX() * v3.getY()
                + v1.getX() * v2.getY() - v2.getX() * v1.getY();
    }

    /**
     * Computes the barycentric coordinates matrix of the triangle defined by the
     * three vertices v1, v2 and v3.
     *
     * @param v1 the first vertex of the triangle
     * @param v2 the second vertex of the triangle
     * @param v3 the third vertex of the triangle
     * @return the barycentric coordinates matrix of the triangle
     */
    protected static Matrix makeBarycentricCoordsMatrix(final Fragment v1,
            final Fragment v2,
            final Fragment v3) {
        final int squareSize = 3;
        Matrix cMat = new Matrix(squareSize, squareSize);

        final double area = triangleArea(v1, v2, v3);
        final int x1 = v1.getX();
        final int y1 = v1.getY();
        final int x2 = v2.getX();
        final int y2 = v2.getY();
        final int x3 = v3.getX();
        final int y3 = v3.getY();
        cMat.set(0, 0, (x2 * y3 - x3 * y2) / area);
        cMat.set(0, 1, (y2 - y3) / area);
        cMat.set(0, 2, (x3 - x2) / area);
        cMat.set(1, 0, (x3 * y1 - x1 * y3) / area);
        cMat.set(1, 1, (y3 - y1) / area);
        cMat.set(1, 2, (x1 - x3) / area);
        cMat.set(2, 0, (x1 * y2 - x2 * y1) / area);
        cMat.set(2, 1, (y1 - y2) / area);
        cMat.set(2, 2, (x2 - x1) / area);

        return cMat;
    }

    /**
     * Rasterizes the triangular face made of the Fragment v1, v2 and v3.
     *
     * @param v1 the first vertex of the triangle
     * @param v2 the second vertex of the triangle
     * @param v3 the third vertex of the triangle
     * @throws SizeMismatchException if the size of the Fragment is not correct.
     */
    public void rasterizeFace(final Fragment v1, final Fragment v2, final Fragment v3)
            throws SizeMismatchException {

        // early exit if the triangle is too small
        final double minArea = 1e-6;
        if (Math.abs(triangleArea(v1, v2, v3)) < minArea) {
            return;
        }
        final Matrix cMat = makeBarycentricCoordsMatrix(v1, v2, v3);

        // iterate over the triangle's bounding box
        // TODO











































    }
}
